package FileIO.FileIOJSON

import FileIO.FileIO
import model.{Card, CardMonth, CardName, CardType, Combination, Deck, DisplayType, GameState, GameStatePendingKoiKoi, GameStatePlanned, GameStateRandom, GameStateSummary, GameStateUninitialized, Player}
import play.api.libs.json.{Format, JsError, JsNull, JsResult, JsString, JsSuccess, JsValue, Json, Reads, Writes}
import play.api.libs.json.OFormat.oFormatFromReadsAndOWrites
import play.api.libs.json.Format.GenericFormat
import FileIO.FileIOJSON.{_}
import model.GameManager.GameManagerInstance.given_GameManager

import java.io.PrintWriter
import scala.io.Source
import scala.language.postfixOps

class FileIOJSON extends FileIO {

  // Stabilisierung der Enums durch explizite String-Mappings

  object DisplayType extends Enumeration {
    type DisplayType = Value
    val GAME         = Value("game")
    val COMBINATIONS = Value("combinations")
    val HELP         = Value("help")
    val SPOILER      = Value("spoiler")
    val SUMMARY      = Value("summary")

    implicit val displayTypeFormat: Format[DisplayType] = new Format[DisplayType] {
      override def writes(o: DisplayType): JsValue = JsString(o.toString)

      override def reads(json: JsValue): JsResult[DisplayType] = json match {
        case JsString("game")         => JsSuccess(GAME)
        case JsString("combinations") => JsSuccess(COMBINATIONS)
        case JsString("help")         => JsSuccess(HELP)
        case JsString("spoiler")      => JsSuccess(SPOILER)
        case JsString("summary")      => JsSuccess(SUMMARY)
        case other                     => JsError(s"Unknown DisplayType: $other")
      }
    }
  }

  object CardMonth extends Enumeration {
    type CardMonth = Value
    val JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER = Value

    implicit val cardMonthFormat: Format[CardMonth] = new Format[CardMonth] {
      override def writes(o: CardMonth): JsValue = JsString(o.toString.toLowerCase)

      override def reads(json: JsValue): JsResult[CardMonth] = json match {
        case JsString(str) =>
          values.find(_.toString.equalsIgnoreCase(str))
            .map(JsSuccess(_))
            .getOrElse(JsError(s"Unknown CardMonth: $str"))
        case _ => JsError("Expected string for CardMonth")
      }
    }
  }

  object CardType extends Enumeration {
    type CardType = Value
    val NORMAL, RIBBON, ANIMAL, BRIGHT = Value

    implicit val cardTypeFormat: Format[CardType] = new Format[CardType] {
      override def writes(o: CardType): JsValue = JsString(o.toString.toLowerCase)

      override def reads(json: JsValue): JsResult[CardType] = json match {
        case JsString(str) =>
          values.find(_.toString.equalsIgnoreCase(str))
            .map(JsSuccess(_))
            .getOrElse(JsError(s"Unknown CardType: $str"))
        case _ => JsError("Expected string for CardType")
      }
    }
  }

  // Implicit formats for nested models
  implicit val cardFormat: Format[Card] = Json.format[Card]
  implicit val deckFormat: Format[Deck] = Json.format[Deck]
  implicit val playerFormat: Format[Player] = Json.format[Player]
  implicit val combinationFormat: Format[Combination] = Json.format[Combination]
  implicit val listCombinationFormat: Format[List[Combination]] = Format(
    Reads.list[Combination],
    Writes.list[Combination]
  )

  // Implementierung der Save-Methode
  override def save(gameState: GameState): Boolean = {
    val json = Json.obj(
      "instanceOf" -> gameState.getClass.toString,
      "players" -> Json.arr(gameState.players.map(p =>
        Json.obj(
          "name" -> p.name,
          "hand" -> Json.obj(
            "deck" -> Json.arr(p.hand.cards.map(c => Json.toJson(c)): _*)
          ),
          "side" -> Json.obj(
            "deck" -> Json.arr(p.side.cards.map(c => Json.toJson(c)): _*)
          ),
          "score" -> p.score,
          "calledKoiKoi" -> p.calledKoiKoi,
          "yakusToIgnore" -> Json.arr(p.yakusToIgnore.map(y => Json.obj("yaku" -> y.unicode)): _*)
        )
      ): _*),
      "deck" -> Json.arr(gameState.deck.cards.map(c => Json.toJson(c)): _*),
      "board" -> Json.arr(gameState.board.cards.map(c => Json.toJson(c)): _*),
      "stdout" -> gameState.stdout,
      "stderr" -> gameState.stderr,
      "displayType" -> gameState.displayType.toString,
      "matchedDeck" -> gameState.matchedDeck.map(deck => Json.arr(deck.cards.map(c => Json.toJson(c)): _*)).getOrElse(JsNull),
      "queuedCard" -> gameState.queuedCard.map(card => Json.toJson(card)).getOrElse(JsNull)
    )

    try {
      val writer = new PrintWriter("gameState.json")
      writer.write(Json.prettyPrint(json))
      writer.close()
      true
    } catch {
      case e: Exception =>
        e.printStackTrace()
        false
    }
  }

  // Formats for GameState and its subclasses
  implicit val gameStateUninitializedFormat: Format[GameStateUninitialized] = Json.format[GameStateUninitialized]
  implicit val gameStateRandomFormat: Format[GameStateRandom] = Json.format[GameStateRandom]
  implicit val gameStatePlannedFormat: Format[GameStatePlanned] = Json.format[GameStatePlanned]
  implicit val gameStatePendingKoiKoiFormat: Format[GameStatePendingKoiKoi] = Json.format[GameStatePendingKoiKoi]
  implicit val gameStateSummaryFormat: Format[GameStateSummary] = Json.format[GameStateSummary]

  // Implementierung der Load-Methode mit stabiler Enum-Konvertierung
  def load: GameState = {
    val source: String = Source.fromFile("gameState.json").getLines.mkString
    val json: JsValue = Json.parse(source)

    (json \ "instanceOf").toOption match {
      case Some(JsString("class model.GameStateUninitialized")) => json.as[GameStateUninitialized]
      case Some(JsString("class model.GameStateRandom"))        => json.as[GameStateRandom]
      case Some(JsString("class model.GameStatePlanned"))       => json.as[GameStatePlanned]
      case Some(JsString("class model.GameStatePendingKoiKoi")) => json.as[GameStatePendingKoiKoi]
      case Some(JsString("class model.GameStateSummary"))       => json.as[GameStateSummary]
      case other => throw new IllegalArgumentException(s"Unknown GameState type: $other")
    }
  }
}